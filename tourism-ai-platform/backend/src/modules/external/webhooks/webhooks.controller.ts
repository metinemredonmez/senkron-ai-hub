import {
  BadRequestException,
  Body,
  Controller,
  ForbiddenException,
  Headers,
  Post,
  RawBodyRequest,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import {
  ApiBody,
  ApiHeader,
  ApiOperation,
  ApiResponse,
  ApiTags,
} from '@nestjs/swagger';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';
import { createHmac } from 'crypto';
import { PinoLogger } from 'nestjs-pino';
import { SkipRateLimit } from '@/common/decorators/skip-rate-limit.decorator';
import { PaymentsWebhookDto } from './dto/payments-webhook.dto';
import { WhatsappWebhookDto } from './dto/whatsapp-webhook.dto';
import { Doktor365WebhookDto } from './dto/doktor365-webhook.dto';

const STANDARD_ERROR_SCHEMA = {
  type: 'object',
  properties: {
    statusCode: { type: 'number' },
    message: { oneOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }] },
    error: { type: 'string' },
  },
};

@ApiTags('webhooks')
@Controller('webhooks')
export class WebhooksController {
  constructor(
    private readonly configService: ConfigService,
    private readonly logger: PinoLogger,
  ) {
    this.logger.setContext(WebhooksController.name);
  }

  @Post('payments')
  @SkipRateLimit()
  @ApiOperation({
    summary: 'Handle payment provider (Stripe/Iyzico) webhook callbacks',
  })
  @ApiBody({ type: PaymentsWebhookDto })
  handlePayments(
    @Body() body: PaymentsWebhookDto,
    @Headers() headers: Record<string, string>,
    @Req() req: RawBodyRequest<Request>,
  ) {
    const rawPayload = this.getRawPayload(req, body);
    const stripeSignature = headers['stripe-signature'];
    const iyzicoSignature = headers['x-iyzico-signature'];
    if (stripeSignature) {
      const secret =
        this.configService.get<string>('STRIPE_WEBHOOK_SECRET') ??
        process.env.STRIPE_WEBHOOK_SECRET ??
        '';
      this.verifySignature(stripeSignature, secret, rawPayload, 'Stripe');
      return { received: true, provider: 'Stripe' };
    }
    if (iyzicoSignature) {
      const secret =
        this.configService.get<string>('IYZICO_WEBHOOK_SECRET') ??
        process.env.IYZICO_WEBHOOK_SECRET ??
        '';
      this.verifySignature(iyzicoSignature, secret, rawPayload, 'Iyzico');
      return { received: true, provider: 'Iyzico' };
    }
    throw new BadRequestException('Unsupported payment webhook provider');
  }

  @Post('whatsapp')
  @SkipRateLimit()
  @ApiOperation({ summary: 'Handle WhatsApp inbound message webhook' })
  @ApiBody({ type: WhatsappWebhookDto })
  handleWhatsapp(@Body() body: WhatsappWebhookDto) {
    // TODO: handle inbound WhatsApp message
    return { ok: true };
  }

  @Post('doktor365')
  @SkipRateLimit()
  @ApiOperation({
    summary: 'Handle Doktor365 webhook callbacks',
    description: 'Validates HMAC signature and processes patient/appointment events.',
  })
  @ApiHeader({
    name: 'x-doktor365-signature',
    description: 'HMAC-SHA256 signature generated by Doktor365',
    required: true,
  })
  @ApiBody({ type: Doktor365WebhookDto })
  @ApiResponse({ status: 200, description: 'Webhook acknowledged' })
  @ApiResponse({
    status: 400,
    description: 'Malformed webhook payload',
    schema: STANDARD_ERROR_SCHEMA,
  })
  @ApiResponse({
    status: 401,
    description: 'Signature validation failed',
    schema: STANDARD_ERROR_SCHEMA,
  })
  handleDoktor365(
    @Body() body: Doktor365WebhookDto,
    @Headers('x-doktor365-signature') signature: string | undefined,
    @Req() req: RawBodyRequest<Request>,
  ) {
    const secret =
      this.configService.get<string>('DOKTOR365_SECRET') ??
      process.env.DOKTOR365_SECRET ??
      '';
    const rawPayload = this.getRawPayload(req, body);
    this.verifySignature(signature, secret, rawPayload, 'Doktor365');

    if (!body?.event || typeof body.event !== 'string') {
      throw new BadRequestException('Doktor365 event type is required');
    }

    switch (body.event) {
      case 'patient.updated':
        this.logger.info(
          { event: body.event, tenantId: body.tenantId },
          'Doktor365 patient update received',
        );
        break;
      case 'appointment.status.changed':
        this.logger.info(
          { event: body.event, tenantId: body.tenantId },
          'Doktor365 appointment status event received',
        );
        break;
      default:
        this.logger.warn({ event: body.event }, 'Unhandled Doktor365 webhook event');
    }

    return { acknowledged: true };
  }

  private getRawPayload(
    req: RawBodyRequest<Request>,
    body: unknown,
  ): Buffer {
    if (req?.rawBody && Buffer.isBuffer(req.rawBody)) {
      return req.rawBody;
    }
    return Buffer.from(
      typeof body === 'string' ? body : JSON.stringify(body ?? {}),
    );
  }

  private verifySignature(
    signature: string | undefined,
    secret: string,
    rawPayload: Buffer,
    provider: string,
  ): void {
    if (!secret) {
      throw new UnauthorizedException(`${provider} webhook secret not configured`);
    }
    if (!signature) {
      throw new UnauthorizedException(`Missing ${provider} signature header`);
    }
    const normalizedSignature = signature.replace(/^sha256=/i, '').trim();
    if (!normalizedSignature) {
      throw new ForbiddenException('Invalid signature');
    }
    const computed = createHmac('sha256', secret)
      .update(rawPayload)
      .digest('hex');
    if (computed !== normalizedSignature) {
      throw new ForbiddenException('Invalid signature');
    }
  }
}
